
/**
 * 根据入口JS文件路径，分析出所有依赖的js文件
 * @public
 * @param filePath - 分析入口文件路径，相对路径
 * @param fileHelper - IFileHelper实例
 * @returns 返回依赖的JS模块数组
 */
export declare function analyseJsDependenies(startPath: string | string[], fileHelper: IFileHelper): Promise<{
    startModules: IModule[];
    modules: IModule[];
}>;

/**
 * 分析单个代码文件的依赖项
 * @param filePath 分析目标文件
 * @param fileHelper - IFileHelper实例
 * @returns 返回IDep依赖项数组
 */
export declare function analyseSingeFile(filePath: string, fileHelper: IFileHelper): Promise<IDep[]>;

/**
 * @public
 */
export declare class Analyzer {
    root: string;
    type: CompileType;
    plugins: AnalyzerPlugin[];
    fileHelper: IFileHelper;
    modules: IModule[];
    graph: Graph | undefined;
    /** 文件是否已经发生改变？ */
    invalid: boolean;
    constructor(option: AnalyzerOption);
    private getEntryDep;
    analyse(): Promise<void>;
    watch(callback: () => void): void;
    serialize(): IAnalyseResult | undefined;
    callPlugin<T extends Exclude<keyof AnalyzerPlugin, 'name'>>(event: T, ...args: any): void;
}

/**
 * @public
 */
export declare interface AnalyzerOption {
    root: string;
    type: CompileType;
    fileHelper?: IFileHelper;
    plugins?: AnalyzerPlugin[];
}

/**
 * @public
 */
export declare interface AnalyzerPlugin {
    name: string;
    created?(analyzer: Analyzer): void;
    beforeAnalyseProcessStart?(graph: Graph, prevGraph: Graph | null): void;
    afterAnalyseProcessComplete?(graph: Graph, cost: number): void;
    beforeModuleBuild?(module: IModule): void;
    onModuleBuildSucceed?(module: IModule, cost: number): void;
    onDepResolveSucceed?(dep: IDep): void;
    onDepResolveFailed?(dep: IDep, error: Error): void;
    onModuleBuildFailed?(module: IModule, cost: number, error: Error): void;
    afterModuleBuild?(module: IModule, cost: number, error: Error | null): void;
    onModuleReuse?(module: IModule): void;
    onModuleSerialize?(module: IModule, data: Record<string, any>): void;
    onSerialize?(data: Record<string, any>): void;
}

/**
 * @public
 */
export declare type CompileType = 'miniprogram' | 'plugin' | 'game' | 'gamePlugin';

/**
 * @public
 */
export declare class FileHelper implements IFileHelper {
    root: string;
    type: CompileType;
    dirSet: Set<string>;
    fileSet: Set<string>;
    constructor(root: string, type?: CompileType);
    private cacheDirName;
    get pattern(): string;
    init(): void;
    stat(filePath: string): IStat | undefined;
    mtime(filePath: string): number;
    exist(filePath: string): boolean;
    existDir(filePath: string): boolean;
    existFile(filePath: string): boolean;
    getFileList(prefix?: string, extName?: string): string[];
    getString(filePath: string): Promise<string>;
    getJSON(filePath: string): Promise<unknown>;
    readdir(dirPath: string): Promise<string[]>;
    onFileChange(type: 'unlink' | 'unlinkDir' | 'add' | 'addDir' | 'change', targetPath: string): Promise<void>;
    watchFileChange(callback: () => void): void;
}

/**
 * @public
 */
export declare type FileType = 'Js' | 'Wxs' | 'Wxml' | 'Wxss';

export declare function findAllDescendant(mod: IModule | IModule[], type: ModuleType): IModule[];

/**
 * @public
 */
export declare type FromType = 'json' | 'file' | 'rule';

/**
 * @public
 */
export declare class Graph {
    status: 'inited' | 'building' | 'completed';
    private fileHelper;
    private pluginDriver;
    private _modules;
    get modules(): IModule[];
    prevGraph: Graph | undefined;
    /** 分析全程耗时 单位ms */
    costTime: number;
    graphContext: GraphContext;
    private runningTasks;
    private pendingTasks;
    private resolve;
    constructor(options: GraphOptions, prevGraph?: Graph);
    private processDep;
    private processDeps;
    private processTask;
    private run;
    private getModule;
    /**
     * 启动构建
     */
    build(dep: IDep | IDep[]): Promise<void>;
    private _build;
}

declare class GraphContext {
    fileHelper: IFileHelper;
    es6Parser: {
        isLayaGame: boolean;
    };
    miniprogram: {
        useExtendedPackages: string[];
    };
    constructor(options: GraphOptions);
    private initMiniprogram;
}

declare interface GraphOptions {
    fileHelper: IFileHelper;
    pluginDriver?: Analyzer;
}

/**
 * @public
 */
export declare interface IAnalyseResult {
    files: IPackageFile[];
    modules: IModuleSerialize[];
}

/**
 * @public
 */
export declare interface IDep {
    from: FromType;
    type: ModuleType;
    request: string;
    path: string | null;
    module: IModule | null;
    originModule: IModule | null;
    error: Error | null;
    resolve(graphContext: GraphContext): Promise<boolean>;
    serialize(): IDepSerialize;
}

/**
 * @public
 */
export declare interface IDepSerialize {
    from: FromType;
    type: ModuleType;
    request: string;
    path: string | null;
    moduleId: ModuleId | null;
    originModuleId: ModuleId;
    error: string | null;
}

/**
 * @public
 */
export declare interface IFileHelper {
    stat(filePath: string): IStat | undefined;
    mtime(filePath: string): number;
    exist(filePath: string): boolean;
    existDir(filePath: string): boolean;
    existFile(filePath: string): boolean;
    getFileList(prefix?: string, extName?: string): string[];
    getString(filePath: string): Promise<string>;
    getJSON(filePath: string): Promise<unknown>;
    readdir(dirPath: string): Promise<string[]>;
    watchFileChange(callback: () => void): void;
}

/**
 * @public
 */
export declare interface IModule {
    id: ModuleId;
    type: ModuleType;
    path: string;
    parentDeps: Set<IDep>;
    deps: Set<IDep>;
    warnings: string[];
    errors: Array<{
        type: ModuleErrorType;
        error: any;
    }>;
    build(graphContext: GraphContext): Promise<IDep[]>;
    reuse?(graphContext: GraphContext): Promise<void>;
    isValid(): boolean;
    serialize(): IModuleSerialize;
    childModules: IModule[];
    findChild(type: ModuleType): IModule | null;
    findChildren(type: ModuleType): IModule[];
}

/**
 * @public
 */
export declare interface IModuleSerialize {
    id: string;
    type: ModuleType;
    path: string;
    parentDeps: Array<IDepSerialize>;
    deps: Array<IDepSerialize>;
    warnings?: string[];
    errors?: Array<{
        type: ModuleErrorType;
        error: string;
    }>;
}

/**
 * @public
 */
export declare interface IPackageFile {
    path: string;
    ext: string;
    size: number;
    moduleId: ModuleId | null;
    subPackage: string | null;
}

/**
 * @public
 */
export declare interface IStat {
    isFile: boolean;
    isDirectory: boolean;
    mtime: number;
    size?: number;
}

/**
 * @public
 */
export declare enum ModuleErrorType {
    APP_JSON_NOT_FOUND = "APP_JSON_NOT_FOUND",
    COMP_JSON_NOT_FOUND = "COMP_JSON_NOT_FOUND",
    PLUGIN_JSON_NOT_FOUND = "PLUGIN_JSON_NOT_FOUND",
    FILE_NOT_FOUND = "FILE_NOT_FOUND",
    FILE_NOT_UTF8 = "FILE_NOT_UTF8",
    JSON_PARSE_ERR = "JSON_PARSE_ERR",
    WXML_PARSE_ERR = "WXML_PARSE_ERR",
    WXSS_PARSE_ERR = "WXSS_PARSE_ERR",
    JS_PARSE_ERR = "JS_PARSE_ERR",
    JS_RESOLVE_DEPENDENCY_ERR = "JS_RESOLVE_DEPENDENCY_ERR",
    WORKER_DIR_NOT_EXIST = "WORKER_DIR_NOT_EXIST"
}

/**
 * @public
 */
export declare type ModuleId = string;

/**
 * @public
 */
export declare type ModuleType = 'Js' | 'Wxml' | 'Wxss' | 'Wxs' | 'Config' | 'MainPackage' | 'SubPackage' | 'Page' | 'Component' | 'Plugin' | 'Worker' | 'FunctionalPages' | 'ContextModule' | 'PluginPackage' | 'GameMainPackage' | 'GameSubPackage';

export { }
